server:
  port: 8081
  tomcat:
    connection-timeout: 120000  # 120초
  servlet:
    session:
      timeout: 120s

spring:
  datasource:
    url: jdbc:mysql://${RDS_ENDPOINT:localhost:3306}/portfolio?useSSL=false&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true&useSSL=false&rewriteBatchedStatements=true
    username: portfolio_user
    password: ${RDS_PASSWORD:portfolio1234}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 20

  jpa:
    defer-datasource-initialization: true
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true
        show_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect
    database-platform: org.hibernate.dialect.MySQL8Dialect

  kafka:
    # 연결시킬 Kafka 서버 주소
    bootstrap-servers: ${KAFKA_PRIVATE_IP:localhost:9092,localhost:19092,localhost:29092}
    consumer:
      # 메시지의 key 역직렬화 방식 : Kafka에서 받아온 메시지를 String으로 변환
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      # 메시지의 value 역직렬화 방식 : Kafka에서 받아온 메시지를 String으로 변환
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer

      # 컨슈머 그룹이 미리 안 만들어져있는 경우에, 컨슈머 그룹을 직접 생성해서 메시지를 처음부터 읽음.
      # 만약 컨슈머 그룹이 이미 만들어져있다면, 해당 컨슈머 그룹이 읽었던 메시지부터 읽음.

      # 이 옵션을 주지 않으면 컨슈머 그룹을 직접 생성해서 메시지를 읽을 때,
      # 기존에 쌓여있던 메시지를 읽지 않고 컨슈머 그룹이 생성된 이후에 들어온 메시지부터 읽어버린다.
      # 그럼 컨슈머 그룹이 생성되기 전에 쌓여있던 메시지들이 처리되지 않고 누락돼버린다.

      # 한 번에 최대 20개까지 가져옴
      max-poll-records: 20
      # 배치 효율을 위해 데이터가 적어도 10ms 정도는 기다렸다가 가져옴
      fetch-max-wait: 10ms
      listener:
        # 리스너 타입을 BATCH로 설정 (List로 받기 위함)
        type: batch
        # 수동 커밋 모드 활성화 (ack.acknowledge() 호출 시 커밋)
        ack-mode: manual_immediate
      auto-offset-reset: earliest

  mail:
    host: ${EC2_PUBLIC_IP:localhost}
    port: 1025
    username:
    password:
    properties:
      mail.smtp.auth: false
      mail.smtp.starttls.enable: false

logging:
  level:
    org.springframework: info

management:
  endpoints:
    web:
      exposure:
        include: "health,metrics,info,prometheus"
  endpoint:
    health:
      show-details: always